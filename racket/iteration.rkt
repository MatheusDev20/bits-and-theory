; n!


; linear recursive proccess to compute n!

(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))

; creates stack of calls that are returned once the function hit the base case.
; make the interpreter keep tracking of all operations that must me computed as the stack grows.


; Iteration proccess to compute n!

(define (factorial n) 
  (fact-iter 1 1 n))


(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))

;; Dont need to keep track of the operations, like linear recursive process, just the current state of the computation
;; product, counter, max-count.

;; Exercise 1.9
(define (+ a b)
  (if (= a 0) 
      b 
      (inc (+ (dec a) b))))

;; The recursive procces generated by using substitution model to evaluate (+ 4 5)
;; No call is performed until the function reach the base case and the proccess start to unwind.

(+ 4 5)
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9

;; The iteration proccess generated by the procedure

(define (+ a b)
  (if (= a 0) 
      b
      (+ (dec a) (inc b))))

(4 + 5)
(3 + 6)
(2 + 7)
(1 + 8)
(0 + 9)

;; Does not create a chain of calls that unwind to get the final answer.
;; Could say that iteration is more memory efficient since recursion needs to keep track of all the calls.

